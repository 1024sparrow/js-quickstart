# Основные моменты про JabaScript

## Типы данных

В JavaScript любая переменная есть что-то вроде QVariant: структура {enum Type type; uint64_t value;}

Типы:

* boolean
* number
* string
* object
* function

Переменная типа object - это что-то вроде QSharedPointer<QMap<QString, QVariant>> - присваивая эту переменную кому-то, мы лишь оставляем указатель, не копию. Возможен обход по ключам.
Предполагается, что object является экземпляром некоторого класса, созданным в куче через new, {} или [].
Примеры создания объектов:
```js
> var example_1 = new MyClass(1,2,3);
> var example_2 = {a:123}; // эквивалетно var example_2 = new Object(); example_2['a'] = 123;
> var example_3 = [1,2,3]; // эквивалентно var example_3 = new Array(1,2,3);
> var example_4 = JSON.parse('{"a": "hello", "b": 123}');
```

Получить тип переменной можно получить посредством специального слова `typeof`:
```js
> typeof 4
'number'

> for (const o of [1,'1',{},[],function(){},, undefined, false]){console.log(`${typeof o}`);}
number
string
object
object
function
undefined
undefined
boolean

```
Обратите внимание: список имеет тип 'object'. Это экземпляр класса Array.

Тип переменной задаётся при инициализации (а после этого может измениться при присваивании):
```js
> var a, b = 5;
undefined
> a
undefined
> b
5
```

Если значение переменной умещается в 64 бита, то в переменной хранится значение переменной, если не умещается (или может не уместиться в соответствии с типом переменной) - адрес объекта в куче.

## Присваивание и сравнение

Сравнение есть с приведением типа (==) и строгое (===).Рекомендуется следить за типами,
все преобразования типов производить явно и сравнивать всегда строго (=== даёт true, если
сравниваемые переменные имеют один и тот же тип одно и то же значение).

При присваивании принимающая переменная принимает тип от дающей переменной. Значение:
- копируется, если тип undefined, boolean, number, string
- копируется указатель (std::shared_ptr или QSharedPointer), если тип object.

Для того, чтобы скопировать объект, надо либо сериализовать в JSON и распарсить (`var copy = JSON.parse(JSON.stringify(someObject));`), либо воспользоваться методом
своего класса, если такой есть (в базовом классе всех объектов Object такого метода нет; такой метод есть, например в классе Array - slice() )

```js
> var a, b;
> a = 5;
> b = a;
> b
5
> a = 6;
> b
5
> ////////////////
> a = '5';
> b = a;
> b
'5'
> a = '6';
> b
'5'
> ////////////////
> a = {aa: 123};
> b = a;
{ aa: 123 }
> a.bb = 456; // эквивалетно a['bb'] = 456;
> b
{ aa: 123, bb: 456 }
> ////////////////
> a = [1,2,3];
> b = a;
> b
[ 1, 2, 3 ]
> a.push('oOPs');
> b
[ 1, 2, 3, 'oOPs' ]
```

## Область видимости переменной

Объявление переменной - var, let или const.

`var` - устаревшая штука. Область видимости - функция, где объявлена. Скозняком через все циклы и условия, переменую можно использовать даже перед вызовом `var <переменная>` в пределах той функции.
`let` и `const` - область видимости как в С/C++, `const` объявляет константную переменную.

## Методы класса Array

Список является контейнеров переменных, которые являются аналогами QVariant, так что в одном списке прекрасно могут уживаться переменных разных типов. Короче говоря, списки в JS нетипизированные.

```js
> var ar = ['a', 'b', 'c'];
undefined
> ar.push('d'); // вставляет в конец и возвращает вставляемый элемент
'd'
> ar
[ 'a', 'b', 'c', 'd' ]
> ar.pop(); // возвращает последний элемент, удаляя при этом его из списка
'd'
> ar
[ 'a', 'b', 'c' ]
> ar.unshift('d'); // вставляет в начало и возвращает вставляемый элемент
'd'
> ar
[ 'd', 'a', 'b', 'c' ]
> ar.shift(); // возвращает первый элемент, удаляя его из списка
'd'
> ar
[ 'a', 'b', 'c' ]
```
Для получения размера списка можно воспользоваться readonly-свойством `length`:

```js
> var ar = [1,2,3];
undefined
> while (ar.length){console.log(ar.pop());}
3
2
1
undefined
```

## Преобразование типов

Преобразование number в string:

```js
> var a, b;
undefined
> a = 5;
5
> b = '' + a; // присвоили результат прибавления числа к пустой строке, т.е. строку '5'
'5'
```

Преобазование из string в number:

```js
> var a,b;
undefined
> a = '5';
'5'
> b = parseInt(a);
5
> b = JSON.parse(a); // можно даже и вот так
5
```

Парсинг JSON:

```js
> var a = '[{"a":1, "b":2}, {"a": "3", "b": "4"}]', b;
undefined
> b = JSON.parse(a);
[ { a: 1, b: 2 }, { a: '3', b: '4' } ]
```

Сериализация в JSON:

```js
> var a =  [ { a: 1, b: 2 }, { a: '3', b: '4' } ];
undefined
> JSON.stringify(a);
'[{"a":1,"b":2},{"a":"3","b":"4"}]'
> a = JSON.stringify(a, undefined, '\t');
'[\n\t{\n\t\t"a": 1,\n\t\t"b": 2\n\t},\n\t{\n\t\t"a": "3",\n\t\t"b": "4"\n\t}\n]'
> console.log(a);
[
    {
        "a": 1,
        "b": 2
    },
    {
        "a": "3",
        "b": "4"
    }
]
undefined
```

## Работа со строками

**Одинарные и двойные кавычки** в JavaScript равнозначны. Разница лишь в том, что внутри двойных кавычек надо экранировать двойные кавычки, а внутри одинарных кавычек - одинарные.

```js
> console.log("'bla-bla'\n\"bla-bla\"");
'bla-bla'
"bla-bla"
undefined
> console.log('\'bla-bla\'\n"bla-bla"');
'bla-bla'
"bla-bla"
undefined
```

Вкусное нововведение в EcmaScript 6 (JavaScript-2015) - **обратные кавычки**. Внутри обатных кавычек можно не экранировать одинарные и двойные кавычки, переносы строк, а ещё можно включать фрагменты кода на JavaScript:

```js
> var a = [1,2,3], varname = 'hello';
undefined
> console.log(`console.log('${varname}', ${JSON.stringify(a)});`);
console.log('helo', [1,2,3]);
undefined
```

## Работа с объектами

Проверить, есть ли поле:
```js
> var a = {aa:123};
undefined
> a.hasOwnProperty('aa');
true
```

Добавить поле:
```js
> var a = {};
undefined
> a.b = 123;
123
> a
{ b: 123 }
> a['c'] = 456; // такое обращение актуально, когда само название поля берётся из переменной
456
> a
{ b: 123, c: 456 }
> a.d = 66;
66
> delete a.d; // удаляем поле из объекта
> a.hasOwnProperty('a') // проверить наличие ключа
false
> a.hasOwnProperty('b')
true
> a instanceof Array // проверить, не является ли объект экземпляром класса Array (в данном случае мы проверяем на то, что a - это список)
false
> [1,2,3] instanceof Array
true
> a = [1,2,3];
[ 1, 2, 3 ]
> a instanceof Array
true
```

## Работа с множествами

```js
> var a;
> a = new Set();
Set {}
> a.add(2);
Set{ 2 }
> a.add(20);
Set{ 2, 20 }
> a.add(20);
Set{ 2, 20 }
> a.delete(20);
Set{ 2 }
> a.add(20);
Set{ 2, 20 }
> a.has(2);
true
> a.has(3);
false
> a.has(20);
true
```

## Циклы

```js
> var a = {aa: 11, bb: 22, cc: [1,2,3], dd: {aaa: 111, bbb: 222}};
undefined
> for (const i in a){ // обход ключей в объекте
... console.log(`${i}: ${a[i]}`);
... }
aa: 11
bb: 22
cc: 1,2,3
dd: [object Object]
undefined
> ////////////////////////////
> a = [1,2,3,4];
[ 1, 2, 3, 4 ]
> for (const o of a){ // обход по элементам списка
 ... console.log(o);
 ... }
1
2
3
4
undefined
> ////////////////////////////
> for (let i = 0 ; i < a.length ; ++i){
 ... console.log(`${i+1}.) ${a[i]}`);
 ... }
1.) 1
2.) 2
3.) 3
4.) 4
undefined
```

## Что ещё не рассмотрели, но что есть

* модули
* try-catch
* классы и наследование
* методы `slice` и `splice` у списков и строк
